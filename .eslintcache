[{"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\index.js":"1","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\reportWebVitals.js":"2","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\App.js":"3","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\SortingVisualizer.jsx":"4","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Visualizer\\Visualizer.jsx":"5","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Menus\\ImageSelectMenu.jsx":"6","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Menus\\SelectMenu.jsx":"7","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Functions\\Misc.js":"8","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Functions\\SortingAlgs.js":"9"},{"size":500,"mtime":499162500000,"results":"10","hashOfConfig":"11"},{"size":362,"mtime":499162500000,"results":"12","hashOfConfig":"11"},{"size":256,"mtime":1608700660052,"results":"13","hashOfConfig":"11"},{"size":6626,"mtime":1609810224842,"results":"14","hashOfConfig":"11"},{"size":10592,"mtime":1609808927731,"results":"15","hashOfConfig":"11"},{"size":4270,"mtime":1609809228072,"results":"16","hashOfConfig":"11"},{"size":3984,"mtime":1609809191854,"results":"17","hashOfConfig":"11"},{"size":685,"mtime":1609809372263,"results":"18","hashOfConfig":"11"},{"size":4361,"mtime":1609810203073,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"4e06p7",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\index.js",[],["40","41"],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\App.js",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\SortingVisualizer.jsx",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Visualizer\\Visualizer.jsx",["42"],"import React, {Component} from \"react\";\r\nimport * as Misc from \"../Functions/Misc\"\r\nimport * as Algs from \"../Functions/SortingAlgs\"\r\n\r\n/* \r\n  The secondary Component on the bottom portion of the page. Stores the heights of bars\r\n  used to visualize each algorithm in the state (as it is needed for rendering), as well\r\n  as the IDs for any queued animations (in case they need to be stopped should a sim or\r\n  randomization be stopped early).\r\n*/\r\nexport default class Visualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      barHeights: [],\r\n    }\r\n    this.timeoutIDs = [];\r\n  }\r\n  \r\n  /*\r\n    Automatically randomizes the bars when this component first appears on the page.\r\n  */\r\n  componentDidMount() {\r\n    this.randomize(this.props.numBars);\r\n  }\r\n\r\n  /*\r\n    Randomizes the bars to some height between 1 and the maximum height of this Component\r\n    (with some vertical padding taken into account).\r\n  */\r\n  randomize(numBars) {\r\n    // *Very Important!* Stops all queued animations before re-randomizing everything\r\n    this.clearAnimations();\r\n\r\n    let list = Array(numBars).fill(0);\r\n    this.setState({barHeights: list});\r\n\r\n    // Shuffle the indices up (creates the \"random\" effect of which bars are chosen)\r\n    let indices = [];\r\n    list.map((item, idx) => indices.push(idx));\r\n    Misc.shuffle(indices);\r\n    \r\n    const maxHeight = (window.innerHeight * 5/6) * 0.8 // 0.8 is for 10% y-padding\r\n    const delay = 1000 / numBars; // Takes 1s total regardless of chosen delay\r\n    const bars = document.getElementsByClassName(\"visBar\");\r\n\r\n    // For each index, set height of that bar to a random number from [1, maxHeight]\r\n    indices.map((item, idx) => {\r\n      list[item] = Misc.randomInt(5, maxHeight);\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        bars[item].style.height = `${list[item]}px`;\r\n      }, idx * delay));\r\n    });\r\n    \r\n    // Update barHeights array to reflect the new random values\r\n    this.timeoutIDs.push(setTimeout(() => {\r\n      this.setState({barHeights: list});\r\n    }, numBars * delay));\r\n  }\r\n  \r\n  /*\r\n    Called each time the visualizer randomizes or simulates in order to prevent\r\n    previously-queued animations from interfering with the new ones.\r\n  */\r\n  clearAnimations() {\r\n    // Clear all queued changes\r\n    this.timeoutIDs.map((item) => clearTimeout(item));\r\n    this.timeoutIDs = [];\r\n\r\n    // Set all bars back to default color and revert progress bar back to zero\r\n    const bars = document.getElementsByClassName(\"visBar\");\r\n    for (let i = 0; i < this.state.barHeights.length; i++) {\r\n      bars[i].style.height = `${this.state.barHeights[i]}px`;\r\n      bars[i].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n    }\r\n    document.getElementById(\"progressBar\").style.width = \"0px\";\r\n  }\r\n\r\n  /*\r\n    Performs a bubble sort on the barHeights list. Takes the resulting swaps\r\n    and queues the relevant animations repersenting each swap to the bars.\r\n  */\r\n  animateBubbleSort(delay) {\r\n    this.clearAnimations();\r\n    \r\n    const bars = document.getElementsByClassName(\"visBar\");\r\n    const origList = this.state.barHeights.slice();\r\n\r\n    // Returns the new list as element 0 and the list of swaps as element 1\r\n    const result = Algs.getBubbleSortAnimations(origList);\r\n    const newList = result[0];\r\n    const swaps = result[1];\r\n\r\n    // For each swap, set the relevant bars to a red color, then swap them,\r\n    // then return them to the original color.\r\n    for (let i = 0; i < swaps.length; i++) {\r\n      const b1 = swaps[i][0];\r\n      const b2 = swaps[i][1];\r\n\r\n      // Make both bars red\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        bars[b1].style.background = \"linear-gradient(#fecaca, #f87171)\";\r\n        bars[b2].style.background = \"linear-gradient(#fecaca, #f87171)\";\r\n      }, i * delay));\r\n\r\n      // Swap bar heights and update progress bar\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        const tmp = bars[b1].style.height;\r\n        bars[b1].style.height = bars[b2].style.height;\r\n        bars[b2].style.height = tmp;\r\n        document.getElementById(\"progressBar\").style.width = `${11.5*(i+1)/swaps.length}rem`;\r\n      }, (i+0.5) * delay));\r\n\r\n      // Make both bars blue again\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        bars[b1].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n        bars[b2].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n      }, (i+1) * delay));\r\n    }\r\n\r\n    // Update barHeights array to reflect sorted values, reset progress bar\r\n    this.timeoutIDs.push(setTimeout(() => {\r\n      document.getElementById(\"progressBar\").style.width = \"0rem\";\r\n      this.setState({barHeights: newList});\r\n    }, swaps.length * delay));\r\n  }\r\n\r\n  /*\r\n    Performs a quick sort on the barHeights list. Takes the resulting swaps\r\n    and queues the relevant animations repersenting each swap to the bars.\r\n  */\r\n  animateQuickSort(delay) {\r\n    this.clearAnimations();\r\n\r\n    const bars = document.getElementsByClassName(\"visBar\");\r\n    const origList = this.state.barHeights.slice();\r\n\r\n    // Returns the new list as element 0 and the list of swaps as element 1\r\n    const result = Algs.getQuickSortAnimations(origList, 0, origList.length-1);\r\n    const newList = result[0];\r\n    const swaps = result[1];\r\n\r\n    // For each swap, set the swapped bars to red and pivot bar to green,\r\n    // swap them, then return them to the original color.\r\n    for (let i = 0; i < swaps.length; i++) {\r\n      const b1 = swaps[i][0];\r\n      const b2 = swaps[i][1];\r\n      const b3 = swaps[i][2];\r\n\r\n      // Perform color changes (b1,b2 to red, b3 to green)\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        bars[b1].style.background = \"linear-gradient(#fecaca, #f87171)\";\r\n        bars[b2].style.background = \"linear-gradient(#fecaca, #f87171)\";\r\n        bars[b3].style.background = \"linear-gradient(#a7f3d0, #34d399)\";\r\n      }, i * delay));\r\n\r\n      // Swap bar heights and update progress bar\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        const tmp = bars[b1].style.height;\r\n        bars[b1].style.height = bars[b2].style.height;\r\n        bars[b2].style.height = tmp;\r\n        document.getElementById(\"progressBar\").style.width = `${11.5*i/swaps.length}rem`;\r\n      }, (i+0.5) * delay));\r\n\r\n      // Make all bars blue again\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        bars[b1].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n        bars[b2].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n        bars[b3].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n      }, (i+1) * delay));\r\n    }\r\n\r\n    // Update barHeights array to reflect sorted values, reset progress bar\r\n    this.timeoutIDs.push(setTimeout(() => {\r\n      document.getElementById(\"progressBar\").style.width = \"0rem\";\r\n      this.setState({barHeights: newList});\r\n    }, swaps.length * delay));\r\n  }\r\n\r\n  /*\r\n    Performs a merge sort on the barHeights list. Takes the resulting comparisons,\r\n    then changes and queues the relevant animations repersenting each swap to the bars.\r\n  */\r\n  animateMergeSort(delay) {\r\n    this.clearAnimations();\r\n\r\n    const bars = document.getElementsByClassName(\"visBar\");\r\n    const origList = this.state.barHeights.slice();\r\n\r\n    // Returns new list as element 0, comparisons as element 1, changes as element 2\r\n    const result = Algs.getMergeSortAnimations(origList, 0, origList.length);\r\n    const newList = result[0];\r\n    const comps = result[1];\r\n    const changes = result[2];\r\n\r\n    // For each comparison, set the two bars as red. After comparisons are over,\r\n    // animate the formation of the \"changed\" partition by making the newly placed\r\n    // bars green. Use a step counter to keep track of each delay easily\r\n    let step = 0;\r\n    for (let i = 0; i < comps.length; i++) {\r\n      const currComps = comps[i];\r\n      const currChanges = changes[i];\r\n\r\n      // Change compared bars to a red color\r\n      for (let j = 0; j < currComps.length; j++) {\r\n        this.timeoutIDs.push(setTimeout(() => {\r\n          bars[currComps[j]].style.background = \"linear-gradient(#fecaca, #f87171)\";\r\n   \r\n          // After one delay \"tick\" change these same bars back to blue\r\n          setTimeout(() => {\r\n            bars[currComps[j]].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n          }, delay);\r\n        }, step * delay));\r\n        step++;\r\n      }\r\n\r\n      // Animate formation of changed partition by changing heights and color to green\r\n      for (let j = 0; j < currChanges.length; j++) {\r\n        this.timeoutIDs.push(setTimeout(() => {\r\n          bars[currChanges[j][0]].style.background = \"linear-gradient(#a7f3d0, #34d399)\";\r\n          bars[currChanges[j][0]].style.height = `${currChanges[j][1]}px`;\r\n        }, step * delay));\r\n        step++;\r\n      }\r\n\r\n      // Update progress bar after each partition is complete\r\n      this.timeoutIDs.push(setTimeout(() => {\r\n        //change all currChanges bars back to blue\r\n        for (let j = 0; j < currChanges.length; j++) {\r\n          bars[currChanges[j][0]].style.background = \"linear-gradient(#bfdbfe, #60a5fa)\";\r\n        }\r\n        document.getElementById(\"progressBar\").style.width = `${11.5*(i+1)/comps.length}rem`;\r\n      }, step * delay));\r\n    }\r\n\r\n    // Update barHeights array to reflect sorted values, reset progress bar\r\n    this.timeoutIDs.push(setTimeout(() => {\r\n      document.getElementById(\"progressBar\").style.width = \"0rem\";\r\n      this.setState({barHeights: newList});\r\n    }, (step+1) * delay));\r\n  }\r\n\r\n  /*\r\n    Runs each time the props or state of this component changes (typically after a\r\n    set of animations has just finished). Simply takes the barHeights array and sets\r\n    each bar to the corresponding index's value.\r\n  */\r\n  render() {\r\n    const numBars = this.state.barHeights.length;\r\n\r\n    let width;\r\n    let padding;\r\n\r\n    if (numBars === 10) {\r\n      width = 100;\r\n      padding = 10;\r\n    }\r\n    else if (numBars === 50) {\r\n      width = 25;\r\n      padding = 5;\r\n    }\r\n    else if (numBars === 100) {\r\n      width = 15;\r\n      padding = 3;\r\n    }\r\n    else if (numBars === 500) {\r\n      width = 2;\r\n      padding = 1.75;\r\n    }\r\n\r\n    return (\r\n      <>\r\n        {this.state.barHeights.map((value, idx) => (\r\n          <div className=\"visBar bg-gradient-to-t from-blue-400 to-blue-200 select-none shadow-md rounded-sm\"\r\n            key={idx}\r\n            style={{height: `${value}px`, width: `${width}px`, marginLeft: `${padding/2}px`, marginRight: `${padding/2}px`}}/>\r\n        ))}\r\n      </>\r\n    );\r\n  }\r\n}","C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Menus\\ImageSelectMenu.jsx",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Menus\\SelectMenu.jsx",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Functions\\Misc.js",[],"C:\\Users\\skamo\\Desktop\\apps\\sorting-visualizer\\src\\SortingVisualizer\\Functions\\SortingAlgs.js",[],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":48,"column":29,"nodeType":"49","messageId":"50","endLine":48,"endColumn":31},"no-native-reassign",["51"],"no-negated-in-lhs",["52"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation"]